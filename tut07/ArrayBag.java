package complete;/** * A class of bags whose entries are stored in a fixed-size array. */public final class ArrayBag<T> implements BagInterface<T> {    //STEP 1: DETERMINES THE DATA FIELDS       /**     * TO-DO: Declares the necessary attributes      * bag: T[]      * numberOfEntries: int     * DEFAULT_CAPACITY: int (30)      * MAX_CAPACITY: int (3000)     */	private final T[] bag;	private int numberOfEntries;	private static final int DEFAULT_CAPACITY = 30;	private static final int MAX_CAPACITY = 3000;	    //STEP 2: IMPLEMENTS THE CONSTRUCTORS    /**     * TO-DO: Creates an empty bag with default capacity     */    public ArrayBag() {        this(DEFAULT_CAPACITY);    } // end default constructor        /**     * TO-DO: Creates an empty bag having a given capacity.     *     * @param desiredCapacity The integer capacity desired.     */    public ArrayBag(int desiredCapacity) {    	if (desiredCapacity <= MAX_CAPACITY) {    		//you write codes here    		// The cast is safe because the new array contains null entries    		@SuppressWarnings("unchecked")    		T[] tempBag = (T[])new Object[desiredCapacity]; // Unchecked cast    		bag = tempBag;    		numberOfEntries = 0;    	}    	else { // desiredCapacity > MAX_CAPACITY    		throw new IllegalStateException("Attempt to create a bag "     										+ "whose capacity exceeds "     										+ "allowed maximum.");    	} // end constructor    }    //STEP 3: IMPLEMENTS THE FUNCTIONS    /**     * TO-DO: Adds a new entry to this bag.     *     * @param newEntry The object to be added as a new entry.     * @return True if the addition is successful, or false if not.     */    public boolean add(T newEntry) {    	boolean result = true;    	if (isArrayFull())    	{    		result = false;    		}    	else    	{ // Assertion: result is true here    		bag[numberOfEntries] = newEntry;    		numberOfEntries++;    		} // end if    	return result;    } // end add       /**     * TO-DO: Retrieves all entries that are in this bag.     *     * @return A newly allocated array of all the entries in this bag.     */    public T[] toArray() {        // the cast is safe because the new array contains null entries    	@SuppressWarnings("unchecked")    	T[] result = (T[]) new Object[numberOfEntries]; // unchecked cast    	for (int index = 0; index < numberOfEntries; index++) {    		result[index] = bag[index];    	} // end for    	return result;    } // end toArray    /**     * TO-DO: Sees whether this bag is empty.     *     * @return True if this bag is empty, or false if not.     */    public boolean isEmpty() {//        if (numberOfEntries == 0)//        	return true;//        else//        	return false;        return numberOfEntries == 0;    }    /**     * TO-DO: Gets the current number of entries in this bag.     *     * @return The integer number of entries currently in this bag.     */    public int getCurrentSize() {        return numberOfEntries;    } //end getCurrentSize    /**     * TO-DO: Counts the number of times a given entry appears in this bag.     *     * @param anEntry The entry to be counted.     * @return The number of times anEntry appears in this bag.     */    public int getFrequencyOf(T anEntry) {        int counter = 0;        for (int index = 0; index < numberOfEntries; index++) {        	if (anEntry.equals(bag[index])) {        		counter++;        	} //end if        } // end for        return counter;    } //end getFrequencyOf    /**     * TO-DO: Tests whether this bag contains a given entry.     *     * @param anEntry The entry to locate.     * @return True if this bag contains anEntry, or false otherwise.     */    public boolean contains(T anEntry) {    	boolean found =false;        for (int index =0; !found && (index<numberOfEntries); index++)        {            if (anEntry.equals(bag[index]))                found =true;        }        return found;    } // end contains    /**     * TO-DO: Removes all entries from this bag.     */    public void clear() {    	while (!isEmpty()) {            remove();        }    } // end clear    /**     * TO-DO: Removes one unspecified entry from this bag, if possible.     *     * @return Either the removed entry, if the removal was successful, or null.     */    public T remove() {    	T result = null;        if (numberOfEntries > 0) {            numberOfEntries--;            result = bag[numberOfEntries];            bag[numberOfEntries] = null;        } // end if        return result;    }    /**     * TO-DO: Removes one occurrence of a given entry from this bag.     *     * @param anEntry The entry to be removed.     * @return True if the removal was successful, or false if not.     */    public boolean remove(T anEntry) {    	int index = getIndexOf(anEntry);    	T result = removeEntry(index);    	return anEntry.equals(result);    }    // TO-DO: Returns true if the array bag is full, or false if not.    private boolean isArrayFull() {        return numberOfEntries >= bag.length;    } // end isArrayFull    // TO-DO: Locates a given entry within the array bag.    // Returns the index of the entry, if located,    // or -1 otherwise.    // Precondition: checkInitialization has been called.    private int getIndexOf(T anEntry) {    	int index =-1;        for ( index=0; index<numberOfEntries; index++)        {            if (bag[index].equals(anEntry))                return index;        }                return index;    }    // TO-DO: Removes and returns the entry at a given index within the array.    // If no such entry exists, returns null.    // Precondition: 0 <= givenIndex < numberOfEntries.    // Precondition: checkInitialization has been called.    private T removeEntry(int givenIndex) {    	T result = null;        if (!isEmpty() && (givenIndex >= 0)) {            result = bag[givenIndex]; // entry to remove            numberOfEntries--;            bag[givenIndex] = bag[numberOfEntries]; // replace entry with last entry            bag[numberOfEntries] = null; // remove last entry        } // end if        return result;    }}